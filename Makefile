.ONESHELL:

# optional include of variables definitions file
-include vars.mk

RECREATE								?= 0
SCRIPT_DEBUG							?= 0
RESET_VENV								?= 0
VENV_DIR								?= .venv
GIT_WEB_URL								?= https://github.com/openshift-kni/eco-ci-cd
GIT_COMMIT_HASH							?= $(shell git rev-parse HEAD)
GIT_TAG									?= $(shell git tag --points-at=HEAD 2>/dev/null)
IMAGE_NAME								?= $(notdir $(GIT_WEB_URL))
IMAGE_REGISTRY 							?= quay.io/telcov10n-ci
IMAGE_VENDOR							?= Red Hat Inc.
IMAGE_MAINTAINER						?= Telcov10n CI/CD Team
IMAGE_LICENSE							?= GPL-3.0
IMAGE_FULL_NAME							?= $(IMAGE_REGISTRY)/$(IMAGE_NAME)
PODMAN_PARAMS 							?=
PODMAN_BUILD_PARAMS 					?= "--platform=linux/amd64"
PODMAN_TAG_PARAMS 						?=
PODMAN_PUSH_PARAMS 						?=
BUILD_ARGS_FILE							?= podman-build-args.current.txt
PY_EXEC									?= python3.11
PY_REQS_BASE_PREFIX						?= requirements-base
PY_REQS									?= $(PY_REQS_BASE_PREFIX) requirements-container
ANSIBLE_BUILDER_EXTRA_BUILD_CLI_ARGS	:= $(PODMAN_BUILD_PARAMS) --build-arg-file ../$(BUILD_ARGS_FILE)
ANSIBLE_BUILDER_VERBOSITY				?= 2
BUILD_DATE								:= $(shell date -u +'%Y-%m-%dT%H:%M:%SZ%:z')
BUILD_ARGS_FILE_HEADER 					:= \# Build arguments file generated by Makefile at $(BUILD_DATE)

## Execution Environment data
EE_NAME									?= $(IMAGE_NAME)-ee
EE_DIR									?= $(EE_NAME)-ubi-amd64
EE_FULL_NAME							?= $(IMAGE_REGISTRY)/$(EE_NAME)
EE_TAG									?= $(GIT_COMMIT_HASH)
EE_BUILD_ARGS_FILE_HEADER 				:= \# Additional ansible-builder Execution Environment build arguments generated by Makefile at $(BUILD_DATE)
EE_NAV_PLAYBOOK							?= playbooks/infra/reporting/test_report_send.yml
EE_NAV_MODE								?= stdout
EE_NAV_PULL_POLICY						?= missing
EE_NAV_EXTRA_VARS						?=

RUN_PLAYBOOK							?= report_send.yml
TEST_PLAYBOOK							?= test_$(TEST_PLAYBOOK)
INVENTORY								?= localhost -c local
ANSIBLE_PARAMS							?= -vv
CLEANUP_LIST							?= .venv .ansible .pytest_cache __pycache__ 
CLEANUP_DIRS							?= collections/ansible_collections/*

# Helper text processing variables
empty :=
space := $(empty) $(empty)
comma := ,

ifeq ($(SCRIPT_DEBUG),1)
	PODMAN_PARAMS += --log-level debug
	ANSIBLE_BUILDER_EXTRA_BUILD_CLI_ARGS += --log-level debug
	ANSIBLE_BUILDER_VERBOSITY = 3
endif
# Newline template
define NEWLINE


endef

# OpenShift Client configuration (can be overridden in vars.mk)
OC_RELEASE								?= 4
OC_VERSION								?= 4.16.0
OC_MIRROR_URL							?= https://mirror.openshift.com/pub

# Build arguments template
define BUILD_ARGS_TEMPLATE
GIT_WEB_URL=$(GIT_WEB_URL)
GIT_COMMIT_HASH=$(GIT_COMMIT_HASH)
GIT_TAG=$(GIT_TAG)
IMAGE_VENDOR=$(IMAGE_VENDOR)
IMAGE_MAINTAINER=$(IMAGE_MAINTAINER)
IMAGE_LICENSE=$(IMAGE_LICENSE)
BUILD_DATE=$(BUILD_DATE)
OC_VERSION=$(OC_VERSION)
OC_RELEASE=$(OC_RELEASE)
OC_MIRROR_URL=$(OC_MIRROR_URL)
endef

# EE-specific environment variables template
define EE_BUILD_ARGS_TEMPLATE
$(if $(ANSIBLE_HOST_KEY_CHECKING),ANSIBLE_HOST_KEY_CHECKING=$(ANSIBLE_HOST_KEY_CHECKING))
$(if $(ANSIBLE_STDOUT_CALLBACK),ANSIBLE_STDOUT_CALLBACK=$(ANSIBLE_STDOUT_CALLBACK))
$(if $(ANSIBLE_COLLECTIONS_PATH),ANSIBLE_COLLECTIONS_PATH=$(ANSIBLE_COLLECTIONS_PATH))
$(if $(ANSIBLE_ROLES_PATH),ANSIBLE_ROLES_PATH=$(ANSIBLE_ROLES_PATH))
$(if $(PYTHONUNBUFFERED),PYTHONUNBUFFERED=$(PYTHONUNBUFFERED))
$(if $(PYTHONDONTWRITEBYTECODE),PYTHONDONTWRITEBYTECODE=$(PYTHONDONTWRITEBYTECODE))
endef

# Generate podman build arguments file
image-build-args-file:
	@echo "Generating build arguments file: $(BUILD_ARGS_FILE)"
	$(if $(filter ee-%,$(MAKECMDGOALS)),\
		$(file > $(BUILD_ARGS_FILE),$(BUILD_ARGS_FILE_HEADER)$(NEWLINE)$(BUILD_ARGS_TEMPLATE)$(NEWLINE)$(EE_BUILD_ARGS_FILE_HEADER)$(NEWLINE)$(subst $(space),$(NEWLINE),$(strip $(EE_BUILD_ARGS_TEMPLATE)))), \
		$(file > $(BUILD_ARGS_FILE),$(BUILD_ARGS_FILE_HEADER)$(NEWLINE)$(BUILD_ARGS_TEMPLATE)))
	@echo "Build arguments file generated"
	@if [ "${SCRIPT_DEBUG}" -eq 1 ]; then \
		echo "=== Build Args Content ==="; \
		cat $(BUILD_ARGS_FILE); \
		echo "========================="; \
	fi

# Build the image
image-build:	image-build-args-file
	@echo "Building image: $(IMAGE_FULL_NAME):$(GIT_COMMIT_HASH)"
	@echo "Using build-args file: $(BUILD_ARGS_FILE)"
	@CMD=(podman $(PODMAN_PARAMS) build
			$(PODMAN_BUILD_PARAMS)
			"--build-arg-file=$(BUILD_ARGS_FILE)"
			"--tag" "$(IMAGE_FULL_NAME):$(GIT_COMMIT_HASH)"
			"--file" Containerfile .)
	@echo "Running command: $${CMD[*]}"
	"$${CMD[@]}" || { echo "failed building $(EE_FULL_NAME):$(EE_TAG)"; exit 1; }
	@echo "Image built: $(IMAGE_FULL_NAME):$(GIT_COMMIT_HASH)"
	@GIT_TAG=$${GIT_TAG:-latest}
	@echo -n "Tagging it as: $(IMAGE_FULL_NAME):$${GIT_TAG} ..."
	@CMD=(
			podman $(PODMAN_PARAMS) tag
			$(PODMAN_TAG_PARAMS)
			"$(IMAGE_FULL_NAME):$(GIT_COMMIT_HASH)"
			"$(IMAGE_FULL_NAME):$${GIT_TAG}")
	@echo "Running command: $${CMD[*]}"
	@"$${CMD[@]}" || { echo "failed building $(EE_FULL_NAME):$(EE_TAG)"; exit 1; }
	@echo "done"

# Push the image
image-push:	image-build
	@echo -n "Pushing: $(IMAGE_FULL_NAME):$(GIT_COMMIT_HASH) ..."
	CMD=(podman $(PODMAN_PARAMS) push
			$(PODMAN_PUSH_PARAMS)
			"$(IMAGE_FULL_NAME):$(GIT_COMMIT_HASH)")
	@echo "Running command: $${CMD[*]}"
	@"$${CMD[@]}" || { echo "failed building $(EE_FULL_NAME):$(EE_TAG)"; exit 1; }
	@echo " done"
	@GIT_TAG=$${GIT_TAG:-latest}
	@echo -n "Pushing: $(IMAGE_FULL_NAME):$${GIT_TAG} ..."
	@CMD=(podman $(PODMAN_PARAMS) push
			$(PODMAN_PUSH_PARAMS)
			"$(IMAGE_FULL_NAME):$${GIT_TAG}")
	@echo "Running command: $${CMD[*]}"
	@"$${CMD[@]}" || { echo "failed building $(EE_FULL_NAME):$(EE_TAG)"; exit 1; }
	@echo " done"

################################################################################
# Python dependencies targets
################################################################################
venv-ensure:
	@echo "Ensuring venv $(VENV_DIR) is installed"
	if [[ -d $(VENV_DIR) ]]; then
		if [[ $(RECREATE) -eq 0 ]]; then
			exit 0
		fi
		rm -rf $(VENV_DIR)
	fi
	mkdir -p $(VENV_DIR)
	$(PY_EXEC) -m venv $(VENV_DIR)
	source $(VENV_DIR)/bin/activate
	$(PY_EXEC) -m pip install --upgrade pip
	for REQ in $(PY_REQS); do
		$(PY_EXEC) -m pip install -r $${REQ}.txt
	done

python-deps-update:	venv-ensure
	@source $(VENV_DIR)/bin/activate && echo "Venv $(VENV_DIR) activated"
	@for req in $(PY_REQS); do
		@if ! [[ -f $${req}.in ]]; then
			@echo "Skipping $${req}.txt, file $${req}.in not found"
			continue
		fi
		@echo "Updating python dependencies for $${req}.txt"
		CMD=(pip-compile --strip-extras)
		@if [[ -f $${req}.txt ]]; then
			CMD+=(--upgrade)
		else
			CMD+=(--annotate)
		fi
		CMD+=($${req}.in)
		CMD+=(-o $${req}.txt)
		@if [[ $(SCRIPT_DEBUG) -gt 0 ]]; then
			CMD+=(--verbose);
			@echo "Running: $${CMD[*]}"
		fi
		@$${CMD[@]} || exit $$?
	done

python-deps-update-interactive:	venv-ensure
	@echo "Updating python dependencies interactively"
	@source $(VENV_DIR)/bin/activate && echo "Venv $(VENV_DIR) activated"
	@for req in $(PY_REQS); do
		@if ! [[ -f "$${req}.in" ]]; then
			@echo "Skipping $${req}.txt, file $${req}.in not found"
			continue
		fi
		CMD=(pip-compile)
		CMD+=($${req}.in)
		CMD+=(-o $${req}.txt)
		CMD+=(--interactive)
		@if [ $(SCRIPT_DEBUG) -eq 1 ]; then
			CMD+=(--verbose);
			echo "Running: $${CMD[*]}"
		fi
		@$${CMD[@]} || exit $$?
	done

python-deps-save:	venv-ensure	python-deps-update
	@echo "Saving python dependencies"
	GIT_PAGER=cat git diff {$(subst $(space),$(comma),$(PY_REQS))}.txt
	git add {$(subst $(space),$(comma),$(PY_REQS))}.txt
	git commit -s -m "Automatic Update of python dependencies done on $(shell date)"


################################################################################
# Generic targets - work from repo root, position-independent
################################################################################

# Default target directory is playbooks/
TARGET_DIR ?= playbooks

# setup ansible dependencies
setup-ansible-deps: venv-ensure
	@echo "Installing Ansible collections from requirements.yml"
	@source $(VENV_DIR)/bin/activate && \
		ansible-galaxy collection install --force --pre -r requirements.yml

# bootstrap = venv-ensure + setup-ansible-deps
bootstrap: setup-ansible-deps
	@echo "‚úÖ Environment ready"

# ansible-lint - lint playbooks/roles under target folder, defaulting to playbooks/
ansible-lint:
	@echo "Running ansible-lint on $(TARGET_DIR)"
	@source $(VENV_DIR)/bin/activate && \
		ansible-lint $(TARGET_DIR)

# test - run tests, auto-discover types
test:
	@echo "Running tests in $(TARGET_DIR)"
	@$(call discover_and_run_tests)

# test-verify - verify test results
test-verify:
	@echo "Verifying test results in $(TARGET_DIR)"
	@$(call run_test_verification,$(CI_TYPE))

# retest - clean rebuild and retest
retest:
	@$(MAKE) clean TARGET_DIR=$(TARGET_DIR)
	@$(MAKE) bootstrap
	@$(MAKE) test TARGET_DIR=$(TARGET_DIR)
	@$(MAKE) test-verify TARGET_DIR=$(TARGET_DIR)

# Auto-discover what types of tests exist in TARGET_DIR
define discover_and_run_tests
	source $(VENV_DIR)/bin/activate && echo "Activated venv $(VENV_DIR)"
	@echo "=== Auto-discovering tests in $(TARGET_DIR) ==="

	@echo "=== Auto-discover Python tests (pytest) ==="
	@if find $(TARGET_DIR) -name "test_*.py" -o -name "*_test.py" | grep -q .; then \
		echo "üìç Found Python tests, running pytest"; \
		pytest -v $(TARGET_DIR); \
	fi

	@echo "=== Discover test playbook for playbook: $(RUN_PLAYBOOK) ==="
	# 2. Check for Ansible playbook tests (explicit)
	@if find $(TARGET_DIR) -maxdepth 1 -name "test_$(RUN_PLAYBOOK)" | grep -q .; then \
		echo "üìç Found Testing Ansible playbooks"; \
		$(MAKE) run-ansible-e2e-test TARGET_DIR=$(TARGET_DIR) TEST_PLAYBOOK=test_$(RUN_PLAYBOOK) COMPONENT=$(CI_TYPE); \
	fi

	@echo "=== Check for role test patterns ==="
	@if [ -f "$(TARGET_DIR)/tests/test.yml" ]; then \
		echo "üìç Found $(TARGET_DIR)/tests/test.yml, running ansible-playbook"; \
		ansible-playbook -i localhost -c local $(TARGET_DIR)/tests/test.yml; \
	fi
endef

# Specific ansible E2E test runner
run-ansible-e2e-test:
	@echo "Running Ansible E2E test for TARGET_DIR=$(TARGET_DIR)"
	@source $(VENV_DIR)/bin/activate && echo "Activated venv $(VENV_DIR)"
	# Use TEST_PLAYBOOK (default: test_$(RUN_PLAYBOOK))
	@echo "Using TEST_PLAYBOOK=$(TEST_PLAYBOOK)"

	# Auto-detect available components from fixtures if COMPONENT not provided
	$(eval COMPONENTS := $(shell find $(TARGET_DIR)/fixtures -maxdepth 1 -type d -exec basename {} \; 2>/dev/null | grep -v fixtures || echo ""))
	$(eval COMPONENT := $(if $(COMPONENT),$(COMPONENT),$(word 1,$(COMPONENTS))))
	@if [ -z "$(COMPONENT)" ]; then
		echo "‚ùå No COMPONENT specified and no fixtures found in $(TARGET_DIR)/fixtures/"
		exit 1
	fi

	@echo "Using COMPONENT=$(COMPONENT) (available: $(COMPONENTS))"

	@echo "Environment file: $(TARGET_DIR)/fixtures/$(COMPONENT)/env.bash"
	# Source environment if it exists
	@if [ -f "$(TARGET_DIR)/fixtures/$(COMPONENT)/env.bash" ]; then
		echo "Sourcing $(TARGET_DIR)/fixtures/$(COMPONENT)/env.bash"
		set -a; source $(TARGET_DIR)/fixtures/$(COMPONENT)/env.bash; set +a
	fi

	@EXTRA_VARS_CHAIN=""
	# Build extra vars chain and run playbook
	$(eval FIXTURES_VARS := $(TARGET_DIR)/fixtures/$(COMPONENT)/$(TEST_PLAYBOOK))
	# Build extra vars chain and run ansible-playbook
	@if [ -f "$(FIXTURES_VARS)" ]; then
		echo "Found fixtures vars: $(FIXTURES_VARS)"
		EXTRA_VARS_CHAIN+=" -e @$(FIXTURES_VARS)"
	else
		echo "No fixtures vars found at: $(FIXTURES_VARS)"
	fi
	CMD=(ansible-playbook -i $(INVENTORY) $(TARGET_DIR)/$(TEST_PLAYBOOK))
	CMD+=($${EXTRA_VARS_CHAIN} $(ANSIBLE_PARAMS))
	@echo "Running: $${CMD[*]}"
	@$${CMD[@]} || exit 1

# Test verification
define run_test_verification
	@echo "Running test verification for COMPONENT=$(1)"
	@EXPECTED_FILE="$(TARGET_DIR)/fixtures/$(1)/event.json"
	@ACTUAL_FILE="$(TARGET_DIR)/actual-event.json"
	@if [ -f "$$EXPECTED_FILE" ] && [ -f "$$ACTUAL_FILE" ]; then
		echo "Verifying $$ACTUAL_FILE against $$EXPECTED_FILE"
		if ! diff --color --unified "$$EXPECTED_FILE" "$$ACTUAL_FILE"; then
			echo "‚ùå Test verification failed"
			exit 1
		fi
		echo "‚úÖ Test verification passed"
	else
		echo "‚ö†Ô∏è  No verification files found, skipping verification"
	fi
endef

################################################################################
# Legacy infra-reporting-* targets (deprecated - use TARGET_DIR instead)
################################################################################
infra-reporting-%:
	@echo "‚ö†Ô∏è  infra-reporting-* targets are deprecated, use: make $* TARGET_DIR=playbooks/infra/reporting"
	@$(MAKE) $* TARGET_DIR=playbooks/infra/reporting

################################################################################
# Execution Environment targets using ansible-builder
################################################################################

# Sync requirements files for execution environment
ee-sync-requirements:
	@echo "Syncing requirements files for execution environment"
	@cp requirements.yml $(EE_DIR)/requirements-ee.yml
	@cp requirements-ee.txt $(EE_DIR)/requirements-ee.txt
	@echo "Requirements files synchronized"

# Build execution environment using ansible-builder
ee-build: image-build-args-file venv-ensure ee-sync-requirements
	@source $(VENV_DIR)/bin/activate && echo "venv $(VENV_DIR) is activated"
	@echo "Building execution environment: $(EE_FULL_NAME):$(EE_TAG)"
	@echo "Using build args from: $(BUILD_ARGS_FILE)"
	@pushd $(PWD) >/dev/null
	@cd $(EE_DIR)
	@CMD=(ansible-builder build
			--tag $(EE_FULL_NAME):$(EE_TAG)
			--extra-build-cli-args="$(ANSIBLE_BUILDER_EXTRA_BUILD_CLI_ARGS)"
			--verbosity $(ANSIBLE_BUILDER_VERBOSITY))
	@echo "Running command: $${CMD[*]}"
	@"$${CMD[@]}" || { echo "failed building $(EE_FULL_NAME):$(EE_TAG)"; exit 1; }
	@echo "Execution environment built: $(EE_FULL_NAME):$(EE_TAG)"
	@GIT_TAG=$${GIT_TAG:-latest}
	@echo -n "Tagging: $(EE_FULL_NAME):$(EE_TAG) as $(EE_FULL_NAME):$${GIT_TAG} ..."
	@CMD=(podman \
		$(PODMAN_PARAMS) \
		tag \
			$(PODMAN_TAG_PARAMS) \
			"$(EE_FULL_NAME):$(EE_TAG)" \
			"$(EE_FULL_NAME):$${GIT_TAG}")
	@echo "Running command: $${CMD[*]}"
	@"$${CMD[@]}" || { echo "failed tagging $(EE_FULL_NAME):$${GIT_TAG}"; exit 1; }
	@echo " done"

# Push execution environment
ee-push: ee-build
	@echo -n "Pushing: $(EE_FULL_NAME):$(EE_TAG) ..."
	@podman \
		$(PODMAN_PARAMS) \
		push \
			$(PODMAN_PUSH_PARAMS) \
			$(EE_FULL_NAME):$(EE_TAG)
	@echo " done"
	@GIT_TAG=$${GIT_TAG:-latest}
	@echo -n "Pushing: $(EE_FULL_NAME):$${GIT_TAG} ..."
	@podman \
		$(PODMAN_PARAMS) \
		push \
			$(PODMAN_PUSH_PARAMS) \
			$(EE_FULL_NAME):$${GIT_TAG}
	@echo " done"

# Clean execution environment build artifacts
ee-clean:
	@echo "Cleaning execution environment build artifacts"
	@rm -rf $(EE_DIR)/build/
	@echo "Build artifacts cleaned"

# Show execution environment info
ee-info:
	@echo "Execution Environment Information:"
	@echo "  EE Directory: $(EE_DIR)"
	@echo "  EE Name: $(EE_NAME)"
	@echo "  EE Tag: $(EE_TAG)"
	@echo "  Full Image: $(EE_FULL_NAME):$(EE_TAG)"
	@echo "  Git Commit Hash: $(GIT_COMMIT_HASH)"
	@echo "  Git Tag (if any): $(GIT_TAG)"
	@echo "  EE uses hash as tag: $(EE_TAG)"


# Run playbook using ansible-navigator with your EE
ee-navigator-run:
	@echo "Running playbook $(EE_NAV_PLAYBOOK) using ansible-navigator with your EE ($(EE_NAME))"
	ansible-navigator run \
		--execution-environment-image $(EE_FULL_NAME):$(EE_TAG) \
		--mode $(EE_NAV_MODE) \
		--pull-policy $(EE_NAV_PULL_POLICY) \
		$(EE_NAV_PLAYBOOK) \
		$(EE_NAV_EXTRA_VARS)

# Interactive ansible-navigator
ansible-nav-interactive:
	ansible-navigator \
		--execution-environment-image $(EE_FULL_NAME):$(EE_TAG) \
		--mode interactive

# Clean target for test artifacts
clean:
	@echo "Cleaning test artifacts..."
	echo "üßπ Regular clean: removing output directory only"
	if [ -n "$(TARGET_DIR)" ]; then
		rm -rf "$(TARGET_DIR)/output"
	else
		echo "‚ö†Ô∏è  TARGET_DIR not specified, skipping clean"
		exit 1
	fi
	@if [[ $(RECREATE) -ne 0 ]]; then
		echo "üóëÔ∏è  RECREATE=1: Deep clean mode"
		echo "Also removing directories: $(CLEANUP_LIST)"
		rm -rf $(CLEANUP_LIST)
	fi
	@echo "‚úÖ Clean completed"

