.ONESHELL:

# optional include of variables definitions file
-include vars.mk

RECREATE								?= 0
SCRIPT_DEBUG							?= 0
RESET_VENV								?= 0
VENV_DIR								?= .venv
GIT_WEB_URL								?= https://github.com/openshift-kni/eco-ci-cd
GIT_COMMIT_HASH							?= $(shell git rev-parse HEAD)
GIT_TAG									?= $(shell git tag --points-at=HEAD 2>/dev/null)
IMAGE_NAME								?= $(notdir $(GIT_WEB_URL))
IMAGE_REGISTRY 							?= quay.io/telcov10n-ci
IMAGE_VENDOR							?= Red Hat Inc.
IMAGE_MAINTAINER						?= Telcov10n CI/CD Team
IMAGE_LICENSE							?= GPL-3.0
IMAGE_FULL_NAME							?= $(IMAGE_REGISTRY)/$(IMAGE_NAME)
PODMAN_PARAMS 							?=
PODMAN_BUILD_PARAMS 					?= "--platform=linux/amd64"
PODMAN_TAG_PARAMS 						?=
PODMAN_PUSH_PARAMS 						?=
BUILD_ARGS_FILE							?= podman-build-args.current.txt
PY_EXEC									?= python3.11
PY_REQS_BASE_PREFIX						?= requirements-base
PY_REQS									?= $(PY_REQS_BASE_PREFIX) requirements-container
ANSIBLE_GALAXY_REQS						?= requirements.yml
ANSIBLE_BUILDER_EXTRA_BUILD_CLI_ARGS	:= $(PODMAN_BUILD_PARAMS) --build-arg-file ../$(BUILD_ARGS_FILE)
ANSIBLE_BUILDER_VERBOSITY				?= 1
BUILD_DATE								:= $(shell date -u +'%Y-%m-%dT%H:%M:%SZ%:z')
BUILD_ARGS_FILE_HEADER 					:= \# Build arguments file generated by Makefile at $(BUILD_DATE)

## Execution Environment data
EE_NAME									?= $(IMAGE_NAME)-ee
EE_DIR									?= $(EE_NAME)-ubi-amd64
EE_FULL_NAME							?= $(IMAGE_REGISTRY)/$(EE_NAME)
EE_TAG									?= $(GIT_COMMIT_HASH)
EE_BUILD_ARGS_FILE_HEADER 				:= \# Additional ansible-builder Execution Environment build arguments generated by Makefile at $(BUILD_DATE)
EE_NAV_PLAYBOOK							?= playbooks/infra/reporting/report_send.yml
EE_NAV_MODE								?= stdout
EE_NAV_PULL_POLICY						?= missing
EE_NAV_EXTRA_VARS						?=

RUN_PLAYBOOK							?= report_send.yml
TEST_PLAYBOOK							?= test_$(TEST_PLAYBOOK)
INVENTORY								?= localhost -c local
ANSIBLE_PARAMS							?= -vv
# Default target directory is playbooks/
TARGET_DIR ?= playbooks
# Default test playbook is test_$(RUN_PLAYBOOK)
TEST_PLAYBOOK ?= test_$(RUN_PLAYBOOK)
# Cleanup list and dirs
CLEANUP_LIST							?= .venv .ansible .pytest_cache __pycache__ 
CLEANUP_DIRS							?= collections/ansible_collections/*


# Helper text processing variables
empty :=
space := $(empty) $(empty)
comma := ,

ICON_FOUND := "üìç "
ICON_LOST := "‚ùå "
ICON_SUCCESS := "‚úÖ "
ICON_FAILED := "üõëÔ∏è "
ICON_WARNING := "‚ö†Ô∏è "
ICON_CLEAN := "üßπ "
ICON_CLEAN_DEEP := "üóëÔ∏è "
ICON_INFO := "‚ÑπÔ∏è "

ifeq ($(SCRIPT_DEBUG),1)
	PODMAN_PARAMS += --log-level debug
	ANSIBLE_BUILDER_EXTRA_BUILD_CLI_ARGS += --log-level debug
	ANSIBLE_BUILDER_VERBOSITY = 3
endif
# Newline template
define NEWLINE


endef

# OpenShift Client configuration (can be overridden in vars.mk)
OC_RELEASE								?= 4
OC_VERSION								?= 4.16.0
OC_MIRROR_URL							?= https://mirror.openshift.com/pub

# Build arguments template
define BUILD_ARGS_TEMPLATE
GIT_WEB_URL=$(GIT_WEB_URL)
GIT_COMMIT_HASH=$(GIT_COMMIT_HASH)
GIT_TAG=$(GIT_TAG)
IMAGE_VENDOR=$(IMAGE_VENDOR)
IMAGE_MAINTAINER=$(IMAGE_MAINTAINER)
IMAGE_LICENSE=$(IMAGE_LICENSE)
BUILD_DATE=$(BUILD_DATE)
OC_VERSION=$(OC_VERSION)
OC_RELEASE=$(OC_RELEASE)
OC_MIRROR_URL=$(OC_MIRROR_URL)
endef

# EE-specific environment variables template
define EE_BUILD_ARGS_TEMPLATE
$(if $(ANSIBLE_HOST_KEY_CHECKING),ANSIBLE_HOST_KEY_CHECKING=$(ANSIBLE_HOST_KEY_CHECKING))
$(if $(ANSIBLE_STDOUT_CALLBACK),ANSIBLE_STDOUT_CALLBACK=$(ANSIBLE_STDOUT_CALLBACK))
$(if $(ANSIBLE_COLLECTIONS_PATH),ANSIBLE_COLLECTIONS_PATH=$(ANSIBLE_COLLECTIONS_PATH))
$(if $(ANSIBLE_ROLES_PATH),ANSIBLE_ROLES_PATH=$(ANSIBLE_ROLES_PATH))
$(if $(PYTHONUNBUFFERED),PYTHONUNBUFFERED=$(PYTHONUNBUFFERED))
$(if $(PYTHONDONTWRITEBYTECODE),PYTHONDONTWRITEBYTECODE=$(PYTHONDONTWRITEBYTECODE))
endef

# Generate podman build arguments file
image-build-args-file:
	@echo "Generating build arguments file: $(BUILD_ARGS_FILE)"
	$(if $(filter ee-%,$(MAKECMDGOALS)),\
		$(file > $(BUILD_ARGS_FILE),$(BUILD_ARGS_FILE_HEADER)$(NEWLINE)$(BUILD_ARGS_TEMPLATE)$(NEWLINE)$(EE_BUILD_ARGS_FILE_HEADER)$(NEWLINE)$(subst $(space),$(NEWLINE),$(strip $(EE_BUILD_ARGS_TEMPLATE)))), \
		$(file > $(BUILD_ARGS_FILE),$(BUILD_ARGS_FILE_HEADER)$(NEWLINE)$(BUILD_ARGS_TEMPLATE)))
	@echo "Build arguments file generated"
	@if [ "${SCRIPT_DEBUG}" -eq 1 ]; then \
		echo "=== Build Args Content ==="; \
		cat $(BUILD_ARGS_FILE); \
		echo "========================="; \
	fi

# Build the image
image-build:	image-build-args-file
	@echo "Building image: $(IMAGE_FULL_NAME):$(GIT_COMMIT_HASH)"
	@echo "Using build-args file: $(BUILD_ARGS_FILE)"
	@CMD=(podman $(PODMAN_PARAMS) build
			$(PODMAN_BUILD_PARAMS)
			"--build-arg-file=$(BUILD_ARGS_FILE)"
			"--tag" "$(IMAGE_FULL_NAME):$(GIT_COMMIT_HASH)"
			"--file" Containerfile .)
	@if [[ $(SCRIPT_DEBUG) -gt 0 ]]; then
		@echo "Running command: $${CMD[*]}"
	fi
	@"$${CMD[@]}" || { echo "$(ICON_FAILED) failed building $(EE_FULL_NAME):$(EE_TAG)"; exit 1; }
	@echo "$(ICON_SUCCESS) Image built: $(IMAGE_FULL_NAME):$(GIT_COMMIT_HASH)"
	@GIT_TAG=$${GIT_TAG:-latest}
	@echo -n "$(ICON_INFO) Tagging it as: $(IMAGE_FULL_NAME):$${GIT_TAG} ..."
	@CMD=(
		podman $(PODMAN_PARAMS) tag
		$(PODMAN_TAG_PARAMS)
		"$(IMAGE_FULL_NAME):$(GIT_COMMIT_HASH)"
		"$(IMAGE_FULL_NAME):$${GIT_TAG}"
	)
	@if [[ $(SCRIPT_DEBUG) -gt 0 ]]; then
		@echo "Running command: $${CMD[*]}"
	fi
	@$${CMD[@]} || { echo "$(ICON_FAILED) failed tagging $(IMAGE_FULL_NAME):$${GIT_TAG}"; exit 1; }
	@echo "$(ICON_SUCCESS) Tagged $(IMAGE_FULL_NAME):$(GIT_COMMIT_HASH) as $(IMAGE_FULL_NAME):$${GIT_TAG}"

# Push the image
image-push:	image-build
	@echo -n "Pushing: $(IMAGE_FULL_NAME):$(GIT_COMMIT_HASH) ..."
	@CMD=(
		podman
		$(PODMAN_PARAMS)
		push
		$(PODMAN_PUSH_PARAMS)
		"$(IMAGE_FULL_NAME):$(GIT_COMMIT_HASH)"
	)
	@if [[ $(SCRIPT_DEBUG) -gt 0 ]]; then
		@echo "Running command: $${CMD[*]}"
	fi
	@"$${CMD[@]}" || { echo "$(ICON_FAILED) failed pushing $(IMAGE_FULL_NAME):$(GIT_COMMIT_HASH)"; exit 1; }
	@echo "$(ICON_SUCCESS) Pushed $(IMAGE_FULL_NAME):$(GIT_COMMIT_HASH)"
	@GIT_TAG=$${GIT_TAG:-latest}
	@echo -n "Pushing: $(IMAGE_FULL_NAME):$${GIT_TAG} ..."
	@CMD=(
		podman
		$(PODMAN_PARAMS)
		push
		$(PODMAN_PUSH_PARAMS)
		"$(IMAGE_FULL_NAME):$${GIT_TAG}"
	)
	@if [[ $(SCRIPT_DEBUG) -gt 0 ]]; then
		@echo "Running command: $${CMD[*]}"
	fi
	@$${CMD[@]} || { echo "$(ICON_FAILED) failed pushing $(IMAGE_FULL_NAME):$${GIT_TAG}"; exit 1; }
	@echo "$(ICON_SUCCESS) Pushed $(IMAGE_FULL_NAME):$${GIT_TAG}"

################################################################################
# Python dependencies targets
################################################################################
venv-ensure:
	@echo "Ensuring venv $(VENV_DIR) is installed"
	@if [[ -d $(VENV_DIR) ]]; then
		@if [[ $(RECREATE) -eq 0 ]]; then
			@exit 0
		fi
		@rm -rf $(VENV_DIR)
	@fi
	@mkdir -p $(VENV_DIR)
	@$(PY_EXEC) -m venv $(VENV_DIR)
	@source $(VENV_DIR)/bin/activate
	@$(PY_EXEC) -m pip install --upgrade pip
	@for req in $(PY_REQS); do
		@$(PY_EXEC) -m pip install -r $${req}.txt
	done
	@echo "$(ICON_SUCCESS) Ensured venv $(VENV_DIR) is installed"

python-deps-update:	venv-ensure
	@source $(VENV_DIR)/bin/activate && echo "Venv $(VENV_DIR) activated"
	@for req in $(PY_REQS); do
		@if ! [[ -f $${req}.in ]]; then
			@echo "Skipping $${req}.txt, file $${req}.in not found"
			continue
		fi
		@echo "Updating python dependencies for $${req}.txt"
		@CMD=(pip-compile --strip-extras)
		@if [[ -f $${req}.txt ]]; then
			@CMD+=(--upgrade)
		else
			@CMD+=(--annotate)
		fi
		@CMD+=($${req}.in)
		@CMD+=(-o $${req}.txt)
		@if [[ $(SCRIPT_DEBUG) -gt 0 ]]; then
			@CMD+=(--verbose);
			@echo "Running: $${CMD[*]}"
		fi
		@$${CMD[@]} || { echo "$(ICON_FAILED) failed updating python dependencies for $${req}.txt"; exit 1; }
		@echo "$(ICON_SUCCESS) Updated python dependencies for $${req}.txt"
	done

python-deps-update-interactive:	venv-ensure
	@echo "Updating python dependencies interactively"
	@source $(VENV_DIR)/bin/activate && echo "Venv $(VENV_DIR) activated"
	@for req in $(PY_REQS); do
		@if ! [[ -f "$${req}.in" ]]; then
			@echo "Skipping $${req}.txt, file $${req}.in not found"
			@continue
		@fi
		@CMD=(pip-compile)
		@CMD+=($${req}.in)
		@CMD+=(-o $${req}.txt)
		@CMD+=(--interactive)
		@if [ $(SCRIPT_DEBUG) -eq 1 ]; then
			@CMD+=(--verbose);
			@echo "Running: $${CMD[*]}"
		@fi
		@$${CMD[@]} || { echo "$(ICON_FAILED) failed updating python dependencies for $${req}.txt"; exit 1; }
		@echo "$(ICON_SUCCESS) Updated python dependencies for $${req}.txt"
	done

python-deps-save:	venv-ensure	python-deps-update
	@echo "Saving python dependencies"
	@GIT_PAGER=cat git diff {$(subst $(space),$(comma),$(PY_REQS))}.txt
	@git add {$(subst $(space),$(comma),$(PY_REQS))}.txt
	@git commit -s -m "Automatic Update of python dependencies done on $(shell date)" || {
		@echo "$(ICON_WARNING) Failed to commit python dependencies";
		@exit 1;
	}
	@echo "$(ICON_SUCCESS) Saved python dependencies"


################################################################################
# Generic targets - work from repo root, position-independent
################################################################################

# setup ansible dependencies
setup-ansible-deps: venv-ensure
	@echo "$(ICON_INFO) Installing Ansible collections from $(ANSIBLE_GALAXY_REQS)"
	@source $(VENV_DIR)/bin/activate && echo "Venv $(VENV_DIR) activated"
	@CMD=(ansible-galaxy collection install --force --pre -r $(ANSIBLE_GALAXY_REQS))
	@if [[ $(SCRIPT_DEBUG) -gt 0 ]]; then
		@echo "Running command: $${CMD[*]}"
	fi
	@$${CMD[@]} || { echo "$(ICON_FAILED) failed installing Ansible collections from $(ANSIBLE_GALAXY_REQS)"; exit 1; }
	@echo "$(ICON_SUCCESS) Installed Ansible collections from $(ANSIBLE_GALAXY_REQS)"

# bootstrap = venv-ensure + setup-ansible-deps
bootstrap: setup-ansible-deps
	@echo "$(ICON_SUCCESS) Environment ready"

# ansible-lint - lint playbooks/roles under target folder, defaulting to playbooks/
ansible-lint:
	@echo "$(ICON_INFO) Running ansible-lint on $(TARGET_DIR)"
	@source $(VENV_DIR)/bin/activate && \
		ansible-lint $(TARGET_DIR) || { echo "$(ICON_FAILED) failed running ansible-lint on $(TARGET_DIR)"; exit 1; }
	@echo "$(ICON_SUCCESS) Ran ansible-lint on $(TARGET_DIR)"

# test - run tests, auto-discover types
test:
	@echo "$(ICON_INFO) Running tests in $(TARGET_DIR)"
	@$(call discover_and_run_tests)

# test-verify - verify test results
test-verify:
	@echo "$(ICON_INFO) Verifying test results in $(TARGET_DIR)"
	@$(call run_test_verification,$(CI_TYPE))

# retest - clean rebuild and retest
retest:
	@$(MAKE) clean TARGET_DIR=$(TARGET_DIR)
	@$(MAKE) bootstrap
	@$(MAKE) test TARGET_DIR=$(TARGET_DIR)
	@$(MAKE) test-verify TARGET_DIR=$(TARGET_DIR)

# Auto-discover what types of tests exist in TARGET_DIR
define discover_and_run_tests
	@echo "$(ICON_INFO) Auto-discovering tests in $(TARGET_DIR)"
	@source $(VENV_DIR)/bin/activate && echo "Activated venv $(VENV_DIR)"
	@echo "$(ICON_INFO) Auto-discovering Python tests (pytest)"
	@if find $(TARGET_DIR) -name "test_*.py" -o -name "*_test.py" | grep -q .; then
		@echo "üìç Found Python tests, running pytest"
		@pytest -v $(TARGET_DIR)
	fi
	@echo "$(ICON_INFO) Discover test playbook for playbook: $(RUN_PLAYBOOK)"
	# 2. Check for Ansible playbook tests (explicit)
	@if find $(TARGET_DIR) -maxdepth 1 -name "test_$(RUN_PLAYBOOK)" | grep -q .; then
		@echo "$(ICON_INFO) Found Testing Ansible playbooks"
		@$(MAKE) run-ansible-e2e-test TARGET_DIR=$(TARGET_DIR) TEST_PLAYBOOK=test_$(RUN_PLAYBOOK) COMPONENT=$(CI_TYPE)
	fi

	@echo "$(ICON_INFO) Check for role test patterns"
	@if [ -f "$(TARGET_DIR)/tests/test.yml" ]; then
		@echo "$(ICON_INFO) Found $(TARGET_DIR)/tests/test.yml, running ansible-playbook"
		@ansible-playbook -i localhost -c local $(TARGET_DIR)/tests/test.yml
	fi
endef

# Specific ansible E2E test runner
run-ansible-e2e-test:
	@echo "$(ICON_INFO) Running Ansible E2E test for TARGET_DIR=$(TARGET_DIR)"
	@source $(VENV_DIR)/bin/activate && echo "Activated venv $(VENV_DIR)"
	# Use TEST_PLAYBOOK (default: test_$(RUN_PLAYBOOK))
	@echo "$(ICON_INFO) Using TEST_PLAYBOOK=$(TEST_PLAYBOOK)"

	# Auto-detect available components from fixtures if COMPONENT not provided
	$(eval COMPONENTS := $(shell find $(TARGET_DIR)/fixtures -maxdepth 1 -type d -exec basename {} \; 2>/dev/null | grep -v fixtures || echo ""))
	$(eval COMPONENT := $(if $(COMPONENT),$(COMPONENT),$(word 1,$(COMPONENTS))))
	@if [ -z "$(COMPONENT)" ]; then
		echo "‚ùå No COMPONENT specified and no fixtures found in $(TARGET_DIR)/fixtures/"
		exit 1
	fi

	@echo "Using COMPONENT=$(COMPONENT) (available: $(COMPONENTS))"

	@echo "Environment file: $(TARGET_DIR)/fixtures/$(COMPONENT)/env.bash"
	# Source environment if it exists
	@if [ -f "$(TARGET_DIR)/fixtures/$(COMPONENT)/env.bash" ]; then
		echo "Sourcing $(TARGET_DIR)/fixtures/$(COMPONENT)/env.bash"
		set -a; source $(TARGET_DIR)/fixtures/$(COMPONENT)/env.bash; set +a
	fi

	@EXTRA_VARS_CHAIN=""
	# Build extra vars chain and run playbook
	$(eval FIXTURES_VARS := $(TARGET_DIR)/fixtures/$(COMPONENT)/$(TEST_PLAYBOOK))
	# Build extra vars chain and run ansible-playbook
	@if [ -f "$(FIXTURES_VARS)" ]; then
		@echo "Found fixtures vars: $(FIXTURES_VARS)"
		@EXTRA_VARS_CHAIN+=" -e @$(FIXTURES_VARS)"
	else
		@echo "No fixtures vars found at: $(FIXTURES_VARS)"
	fi
	@CMD=(ansible-playbook -i $(INVENTORY) $(TARGET_DIR)/$(TEST_PLAYBOOK))
	@CMD+=($${EXTRA_VARS_CHAIN} $(ANSIBLE_PARAMS))
	@if [[ $(SCRIPT_DEBUG) -gt 0 ]]; then
		@echo "Running: $${CMD[*]}"
	fi
	@$${CMD[@]} || { echo "$(ICON_FAILED) failed running ansible-playbook $(TARGET_DIR)/$(TEST_PLAYBOOK)"; exit 1; }
	@echo "$(ICON_SUCCESS) Ran ansible-playbook $(TARGET_DIR)/$(TEST_PLAYBOOK)"

# Test verification
define run_test_verification
	@echo "Running test verification for COMPONENT=$(1)"
	@EXPECTED_FILE="$(TARGET_DIR)/fixtures/$(1)/event.json"
	@ACTUAL_FILE="$(TARGET_DIR)/actual-event.json"
	@if [ -f "$$EXPECTED_FILE" ] && [ -f "$$ACTUAL_FILE" ]; then
		echo "Verifying $$ACTUAL_FILE against $$EXPECTED_FILE"
		if ! diff --color --unified "$$EXPECTED_FILE" "$$ACTUAL_FILE"; then
			echo "‚ùå Test verification failed"
			exit 1
		fi
		echo "‚úÖ Test verification passed"
	else
		echo "‚ö†Ô∏è  No verification files found, skipping verification"
	fi
endef

################################################################################
# Legacy infra-reporting-* targets (deprecated - use TARGET_DIR instead)
################################################################################
# infra-reporting-%:
# 	@echo "‚ö†Ô∏è  infra-reporting-* targets are deprecated, use: make $* TARGET_DIR=playbooks/infra/reporting"
# 	@$(MAKE) $* TARGET_DIR=playbooks/infra/reporting

################################################################################
# Execution Environment targets using ansible-builder
################################################################################

# Sync requirements files for execution environment
ee-sync-requirements:
	@echo "Syncing requirements files for execution environment"
	@cp requirements.yml $(EE_DIR)/requirements-ee.yml
	@cp requirements-ee.txt $(EE_DIR)/requirements-ee.txt
	@echo "$(ICON_SUCCESS) Requirements files synchronized"

# Build execution environment using ansible-builder
ee-build: image-build-args-file venv-ensure ee-sync-requirements
	@source $(VENV_DIR)/bin/activate && echo "venv $(VENV_DIR) is activated"
	@echo "$(ICON_INFO) Building execution environment: $(EE_FULL_NAME):$(EE_TAG)"
	@echo "$(ICON_INFO) Using build args from: $(BUILD_ARGS_FILE)"
	@pushd $(PWD) >/dev/null
	@cd $(EE_DIR)
	@CMD=(ansible-builder build --no-cache -t $(EE_FULL_NAME):$(EE_TAG) --extra-build-cli-args="$(ANSIBLE_BUILDER_EXTRA_BUILD_CLI_ARGS)" -v $(ANSIBLE_BUILDER_VERBOSITY))
	@if [[ $(SCRIPT_DEBUG) -gt 0 ]]; then
		echo "Running command: $${CMD[*]}"
	fi
	@"$${CMD[@]}" || { echo "$(ICON_FAILED) failed building $(EE_FULL_NAME):$(EE_TAG)"; exit 1; }
	@echo "$(ICON_SUCCESS) Execution environment built: $(EE_FULL_NAME):$(EE_TAG)"
	@popd >/dev/null
	@GIT_TAG=$${GIT_TAG:-latest}
	@echo -n "$(ICON_INFO) Tagging: $(EE_FULL_NAME):$(EE_TAG) as $(EE_FULL_NAME):$${GIT_TAG} ..."
	@CMD=(
		podman
		$(PODMAN_PARAMS)
		tag
		$(PODMAN_TAG_PARAMS)
		"$(EE_FULL_NAME):$(EE_TAG)"
		"$(EE_FULL_NAME):$${GIT_TAG}"
	)
	@if [[ $(SCRIPT_DEBUG) -gt 0 ]]; then
		@echo "Running command: $${CMD[*]}"
	fi
	@$${CMD[@]} || { echo "$(ICON_FAILED) failed tagging $(EE_FULL_NAME):$${GIT_TAG}"; exit 1; }
	@echo "$(ICON_SUCCESS) Tagged $(EE_FULL_NAME):$(EE_TAG) as $(EE_FULL_NAME):$${GIT_TAG}"

# Push execution environment
ee-push: ee-build
	@echo -n "$(ICON_INFO) Pushing: $(EE_FULL_NAME):$(EE_TAG) ..."
	@CMD=(
		podman
		$(PODMAN_PARAMS)
		push
		$(PODMAN_PUSH_PARAMS)
		"$(EE_FULL_NAME):$(EE_TAG)"
	)
	@if [[ $(SCRIPT_DEBUG) -gt 0 ]]; then
		@echo "Running command: $${CMD[*]}"
	fi
	@"$${CMD[@]}" || { echo "$(ICON_FAILED) failed pushing $(EE_FULL_NAME):$(EE_TAG)"; exit 1; }
	@echo "$(ICON_SUCCESS) Pushed $(EE_FULL_NAME):$(EE_TAG)"
	@GIT_TAG=$${GIT_TAG:-latest}
	@echo -n "$(ICON_INFO) Pushing: $(EE_FULL_NAME):$${GIT_TAG} ..."
	@CMD=(
		podman
		$(PODMAN_PARAMS)
		push
		$(PODMAN_PUSH_PARAMS)
		"$(EE_FULL_NAME):$${GIT_TAG}"
	)
	@if [[ $(SCRIPT_DEBUG) -gt 0 ]]; then
		@echo "Running command: $${CMD[*]}"
	fi
	@"$${CMD[@]}" || { echo "$(ICON_FAILED) failed pushing $(EE_FULL_NAME):$${GIT_TAG}"; exit 1; }
	@echo "$(ICON_SUCCESS) Pushed $(EE_FULL_NAME):$${GIT_TAG}"

# Clean execution environment build artifacts
ee-clean:
	@echo "$(ICON_CLEAN) Cleaning execution environment build artifacts"
	@rm -rf $(EE_DIR)/build/
	@echo "$(ICON_SUCCESS) Build artifacts cleaned"

# Show execution environment info
ee-info:
	@echo "Execution Environment Information:"
	@echo "  EE Directory: $(EE_DIR)"
	@echo "  EE Name: $(EE_NAME)"
	@echo "  EE Tag: $(EE_TAG)"
	@echo "  Full Image: $(EE_FULL_NAME):$(EE_TAG)"
	@echo "  Git Commit Hash: $(GIT_COMMIT_HASH)"
	@echo "  Git Tag (if any): $(GIT_TAG)"
	@echo "  EE uses hash as tag: $(EE_TAG)"


# Run playbook using ansible-navigator with your EE
ee-navigator-run:
	@echo "Running playbook $(EE_NAV_PLAYBOOK) using ansible-navigator with your EE ($(EE_NAME))"
	ansible-navigator run \
		--execution-environment-image $(EE_FULL_NAME):$(EE_TAG) \
		--mode $(EE_NAV_MODE) \
		--pull-policy $(EE_NAV_PULL_POLICY) \
		$(EE_NAV_PLAYBOOK) \
		$(EE_NAV_EXTRA_VARS)

# Interactive ansible-navigator
ansible-nav-interactive:
	ansible-navigator \
		--execution-environment-image $(EE_FULL_NAME):$(EE_TAG) \
		--mode interactive

# Clean target for test artifacts
clean:
	@echo "Cleaning test artifacts..."
	echo "üßπ Regular clean: removing output directory only"
	if [ -n "$(TARGET_DIR)" ]; then
		rm -rf "$(TARGET_DIR)/output"
	else
		echo "‚ö†Ô∏è  TARGET_DIR not specified, skipping clean"
		exit 1
	fi
	@if [[ $(RECREATE) -ne 0 ]]; then
		echo "üóëÔ∏è  RECREATE=1: Deep clean mode"
		echo "Also removing directories: $(CLEANUP_LIST)"
		rm -rf $(CLEANUP_LIST)
	fi
	@echo "‚úÖ Clean completed"

