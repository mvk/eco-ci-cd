.ONESHELL:

# optional include of variables definitions file
-include vars.mk

SCRIPT_DEBUG							?= 0
RESET_VENV								?= 0
VENV_DIR								?= .venv
GIT_WEB_URL								?= https://github.com/openshift-kni/eco-ci-cd
GIT_COMMIT_HASH							?= $(shell git rev-parse HEAD)
GIT_TAG									?= $(shell git tag --points-at=HEAD 2>/dev/null)
IMAGE_NAME								?= $(notdir $(GIT_WEB_URL))
IMAGE_REGISTRY 							?= quay.io/telcov10n-ci
IMAGE_VENDOR							?= Red Hat Inc.
IMAGE_MAINTAINER						?= Telcov10n CI/CD Team
IMAGE_LICENSE							?= GPL-3.0
IMAGE_FULL_NAME							?= $(IMAGE_REGISTRY)/$(IMAGE_NAME)
PODMAN_PARAMS 							?= 
PODMAN_BUILD_PARAMS 					?= --platform=linux/amd64
PODMAN_TAG_PARAMS 						?=
PODMAN_PUSH_PARAMS 						?=
BUILD_ARGS_FILE							?= podman-build-args.current.txt
PY_EXEC									?= python3.11
PY_REQS_BASE_PREFIX						?= requirements-base
PY_REQS									?= $(PY_REQS_BASE_PREFIX) requirements-container
ANSIBLE_BUILDER_EXTRA_BUILD_CLI_ARGS	:= $(PODMAN_BUILD_PARAMS) --build-arg-file ../$(BUILD_ARGS_FILE)
ANSIBLE_BUILDER_VERBOSITY				?= 2
BUILD_DATE								:= $(shell date -u +'%Y-%m-%dT%H:%M:%SZ%:z')
BUILD_ARGS_FILE_HEADER 					:= \# Build arguments file generated by Makefile at $(BUILD_DATE)

## Execution Environment data
EE_NAME									?= $(IMAGE_NAME)-ee
EE_DIR									?= $(EE_NAME)-ubi-amd64
EE_FULL_NAME							?= $(IMAGE_REGISTRY)/$(EE_NAME)
EE_TAG									?= $(GIT_COMMIT_HASH)
EE_BUILD_ARGS_FILE_HEADER 				:= \# Additional ansible-builder Execution Environment build arguments generated by Makefile at $(BUILD_DATE)
EE_NAV_PLAYBOOK							?= playbooks/infra/reporting/test_report_send.yml
EE_NAV_MODE								?= stdout
EE_NAV_PULL_POLICY						?= missing
EE_NAV_EXTRA_VARS						?=

# Helper text processing variables
empty :=
space := $(empty) $(empty)

ifeq ($(SCRIPT_DEBUG),1)
	PODMAN_PARAMS += --log-level debug
	ANSIBLE_BUILDER_EXTRA_BUILD_CLI_ARGS += --log-level debug
	ANSIBLE_BUILDER_VERBOSITY = 3
endif

ifeq ($(RESET_VENV),1)
	rm -rf $(VENV_DIR)
endif

# Newline template
define NEWLINE


endef

# OpenShift Client configuration (can be overridden in vars.mk)
OC_RELEASE								?= 4
OC_VERSION								?= 4.16.0
OC_MIRROR_URL							?= https://mirror.openshift.com/pub

# Build arguments template
define BUILD_ARGS_TEMPLATE
GIT_WEB_URL=$(GIT_WEB_URL)
GIT_COMMIT_HASH=$(GIT_COMMIT_HASH)
GIT_TAG=$(GIT_TAG)
IMAGE_VENDOR=$(IMAGE_VENDOR)
IMAGE_MAINTAINER=$(IMAGE_MAINTAINER)
IMAGE_LICENSE=$(IMAGE_LICENSE)
BUILD_DATE=$(BUILD_DATE)
OC_VERSION=$(OC_VERSION)
OC_RELEASE=$(OC_RELEASE)
OC_MIRROR_URL=$(OC_MIRROR_URL)
endef

# EE-specific environment variables template
define EE_BUILD_ARGS_TEMPLATE
$(if $(ANSIBLE_HOST_KEY_CHECKING),ANSIBLE_HOST_KEY_CHECKING=$(ANSIBLE_HOST_KEY_CHECKING))
$(if $(ANSIBLE_STDOUT_CALLBACK),ANSIBLE_STDOUT_CALLBACK=$(ANSIBLE_STDOUT_CALLBACK))
$(if $(ANSIBLE_COLLECTIONS_PATH),ANSIBLE_COLLECTIONS_PATH=$(ANSIBLE_COLLECTIONS_PATH))
$(if $(ANSIBLE_ROLES_PATH),ANSIBLE_ROLES_PATH=$(ANSIBLE_ROLES_PATH))
$(if $(PYTHONUNBUFFERED),PYTHONUNBUFFERED=$(PYTHONUNBUFFERED))
$(if $(PYTHONDONTWRITEBYTECODE),PYTHONDONTWRITEBYTECODE=$(PYTHONDONTWRITEBYTECODE))
endef

# Generate podman build arguments file
image-build-args-file:
	@echo "Generating build arguments file: $(BUILD_ARGS_FILE)"
	$(if $(filter ee-%,$(MAKECMDGOALS)),\
		$(file > $(BUILD_ARGS_FILE),$(BUILD_ARGS_FILE_HEADER)$(NEWLINE)$(BUILD_ARGS_TEMPLATE)$(NEWLINE)$(EE_BUILD_ARGS_FILE_HEADER)$(NEWLINE)$(subst $(space),$(NEWLINE),$(strip $(EE_BUILD_ARGS_TEMPLATE)))), \
		$(file > $(BUILD_ARGS_FILE),$(BUILD_ARGS_FILE_HEADER)$(NEWLINE)$(BUILD_ARGS_TEMPLATE)))
	@echo "Build arguments file generated"
	@if [ "${SCRIPT_DEBUG}" -eq 1 ]; then \
		echo "=== Build Args Content ==="; \
		cat $(BUILD_ARGS_FILE); \
		echo "========================="; \
	fi

# Build the image
image-build:	image-build-args-file
	@echo "Building image: $(IMAGE_FULL_NAME):$(GIT_COMMIT_HASH)"
	@echo "Using build-args file: $(BUILD_ARGS_FILE)"
	@podman \
		$(PODMAN_PARAMS) \
		build \
			$(PODMAN_BUILD_PARAMS) \
			--build-arg-file $(BUILD_ARGS_FILE) \
			--tag $(IMAGE_FULL_NAME):$(GIT_COMMIT_HASH) \
			-f Containerfile \
			.
	@echo "Image built: $(IMAGE_FULL_NAME):$(GIT_COMMIT_HASH)"
	@GIT_TAG=$${GIT_TAG:-latest}
	@echo -n "Tagging it as: $(IMAGE_FULL_NAME):$${GIT_TAG} ..."
	@podman \
		$(PODMAN_PARAMS) \
		tag \
			$(PODMAN_TAG_PARAMS) \
			$(IMAGE_FULL_NAME):$(GIT_COMMIT_HASH) \
			$(IMAGE_FULL_NAME):$${GIT_TAG}
	@echo "done"

# Push the image
image-push:	image-build
	@echo -n "Pushing: $(IMAGE_FULL_NAME):$(GIT_COMMIT_HASH) ..."
	@podman \
		$(PODMAN_PARAMS) \
		push \
			$(PODMAN_PUSH_PARAMS) \
			$(IMAGE_FULL_NAME):$(GIT_COMMIT_HASH)
	@echo " done"
	@GIT_TAG=$${GIT_TAG:-latest}
	@echo -n "Pushing: $(IMAGE_FULL_NAME):$${GIT_TAG} ..."
	@podman \
		$(PODMAN_PARAMS) \
		push \
			$(PODMAN_PUSH_PARAMS) \
			$(IMAGE_FULL_NAME):$${GIT_TAG}
	@echo " done"

################################################################################
# Python dependencies targets
################################################################################
venv-ensure:
	@echo "Ensuring venv $(VENV_DIR) is installed"
	if [[ -d $(VENV_DIR) ]]; then
		if [[ $(RECREATE) -eq 0 ]]; then
			exit 0
		fi
		rm -rf $(VENV_DIR)
	fi
	mkdir -p $(VENV_DIR)
	$(PY_EXEC) -m venv $(VENV_DIR)
	source $(VENV_DIR)/bin/activate
	$(PY_EXEC) -m pip install --upgrade pip
	for REQ in $(PY_REQS); do
		$(PY_EXEC) -m pip install -r $${REQ}.txt
	done

python-deps-update:	venv-ensure
	source $(VENV_DIR)/bin/activate && echo "Venv $(VENV_DIR) activated"
	@echo "Updating python dependencies"
	CMD=(pip-compile --strip-extras)
	if [ -f $(PY_REQS).txt ]; then
		CMD+=(--upgrade)
	else \
		CMD+=(--annotate)
	fi
	CMD+=($(PY_REQS).in)
	CMD+=(-o $(PY_REQS).txt)
	if [ "${SCRIPT_DEBUG}" -eq 1 ]; then \
		CMD+=(--verbose); \
		echo "Running: $${CMD[*]}"
	fi
	$${CMD[@]}

python-deps-update-interactive:	venv-ensure
	@echo "Updating python dependencies interactively"
	source $(VENV_DIR)/bin/activate && echo "Venv $(VENV_DIR) activated"
	CMD=(pip-compile)
	CMD+=($(PY_REQS).in)
	CMD+=(-o $(PY_REQS).txt)
	CMD+=(--interactive)

python-deps-save:	venv-ensure	python-deps-update
	@echo "Saving python dependencies"
	GIT_PAGER=cat git diff $(PY_REQS).txt
	git add $(PY_REQS).txt
	git commit -s -m "Automatic Update of python dependencies done on $(shell date)"


################################################################################
# Generic targets - work from repo root, position-independent
################################################################################

# Default target directory is playbooks/
TARGET_DIR ?= playbooks

# setup ansible dependencies
setup-ansible-deps: venv-ensure
	@echo "Installing Ansible collections from requirements.yml"
	@source $(VENV_DIR)/bin/activate && \
		ansible-galaxy collection install --force --pre -r requirements.yml

# bootstrap = venv-ensure + setup-ansible-deps
bootstrap: venv-ensure setup-ansible-deps
	@echo "‚úÖ Environment ready"

# ansible-lint - lint playbooks/roles under target folder, defaulting to playbooks/
ansible-lint:
	@echo "Running ansible-lint on $(TARGET_DIR)"
	@source $(VENV_DIR)/bin/activate && \
		ansible-lint $(TARGET_DIR)

# test - run tests, auto-discover types
test:
	@echo "Running tests in $(TARGET_DIR)"
	@$(call discover_and_run_tests)

# test-verify - verify test results
test-verify:
	@echo "Verifying test results in $(TARGET_DIR)"
	@$(call run_test_verification)

# retest - clean rebuild and retest
retest:
	@$(MAKE) bootstrap RESET_VENV=1
	@$(MAKE) test TARGET_DIR=$(TARGET_DIR)
	@$(MAKE) test-verify TARGET_DIR=$(TARGET_DIR)

# Auto-discover what types of tests exist in TARGET_DIR
define discover_and_run_tests
	@echo "=== Auto-discovering tests in $(TARGET_DIR) ==="

	# 1. Auto-discover Python tests (pytest)
	@if find $(TARGET_DIR) -name "test_*.py" -o -name "*_test.py" | grep -q .; then \
		echo "üìç Found Python tests, running pytest"; \
		source $(VENV_DIR)/bin/activate && pytest -v $(TARGET_DIR); \
	fi

	# 2. Check for Ansible playbook tests (explicit)
	@if [ -f "$(TARGET_DIR)/report_send.yml" ] && [ -d "$(TARGET_DIR)/fixtures" ]; then \
		echo "üìç Found Ansible reporting tests"; \
		$(MAKE) run-ansible-reporting-test TARGET_DIR=$(TARGET_DIR); \
	fi

	# 3. Check for other explicit test patterns
	@if [ -f "$(TARGET_DIR)/test.yml" ]; then \
		echo "üìç Found test.yml, running ansible-playbook"; \
		source $(VENV_DIR)/bin/activate && ansible-playbook -i localhost -c local $(TARGET_DIR)/test.yml; \
	fi
endef

# Specific ansible reporting test runner
run-ansible-reporting-test:
	@echo "Running Ansible reporting test for TARGET_DIR=$(TARGET_DIR)"

	# Auto-detect available CI types from fixtures
	$(eval CI_TYPES := $(shell find $(TARGET_DIR)/fixtures -maxdepth 1 -type d -exec basename {} \; 2>/dev/null | grep -v fixtures || echo ""))
	$(eval CI_TYPE := $(if $(CI_TYPE),$(CI_TYPE),$(word 1,$(CI_TYPES))))
	@if [ -z "$(CI_TYPE)" ]; then \
		echo "‚ùå No CI_TYPE specified and no fixtures found in $(TARGET_DIR)/fixtures/"; \
		exit 1; \
	fi
	@echo "Using CI_TYPE=$(CI_TYPE) (available: $(CI_TYPES))"
	@echo "Environment file: $(TARGET_DIR)/fixtures/$(CI_TYPE)/env.bash"
	@echo "Test vars: $(TARGET_DIR)/fixtures/$(CI_TYPE)/test_report_send.yml"
	# Source environment if it exists
	@if [ -f "$(TARGET_DIR)/fixtures/$(CI_TYPE)/env.bash" ]; then \
		echo "Sourcing $(TARGET_DIR)/fixtures/$(CI_TYPE)/env.bash"; \
		set -a; source $(TARGET_DIR)/fixtures/$(CI_TYPE)/env.bash; set +a; \
	fi
	# Run the playbook
	@source $(VENV_DIR)/bin/activate && \
		ansible-playbook -i localhost -c local \
			$(TARGET_DIR)/report_send.yml \
			-e @$(TARGET_DIR)/fixtures/$(CI_TYPE)/test_report_send.yml \
			-vv

# Test verification
define run_test_verification
	@if [ -f "$(TARGET_DIR)/fixtures/$(CI_TYPE)/event.json" ] && [ -f "$(TARGET_DIR)/actual-event.json" ]; then \
		echo "Verifying $(TARGET_DIR)/actual-event.json against $(TARGET_DIR)/fixtures/$(CI_TYPE)/event.json"; \
		if ! diff --color --unified $(TARGET_DIR)/fixtures/$(CI_TYPE)/event.json $(TARGET_DIR)/actual-event.json; then \
			echo "‚ùå Test verification failed"; \
			exit 1; \
		fi; \
		echo "‚úÖ Test verification passed"; \
	else \
		echo "‚ö†Ô∏è  No verification files found, skipping verification"; \
	fi
endef

################################################################################
# Legacy infra-reporting-* targets (deprecated - use TARGET_DIR instead)
################################################################################
infra-reporting-%:
	@echo "‚ö†Ô∏è  infra-reporting-* targets are deprecated, use: make $* TARGET_DIR=playbooks/infra/reporting"
	@$(MAKE) $* TARGET_DIR=playbooks/infra/reporting

################################################################################
# Execution Environment targets using ansible-builder
################################################################################

# Sync requirements files for execution environment
ee-sync-requirements:
	@echo "Syncing requirements files for execution environment"
	@cp requirements.yml $(EE_DIR)/requirements-ee.yml
	@cp requirements-ee.txt $(EE_DIR)/requirements-ee.txt
	@echo "Requirements files synchronized"

# Build execution environment using ansible-builder
ee-build: image-build-args-file venv-ensure ee-sync-requirements
	@echo "Building execution environment: $(EE_FULL_NAME):$(EE_TAG)"
	@echo "Using build args from: $(BUILD_ARGS_FILE)"
	@source $(VENV_DIR)/bin/activate && \
		cd $(EE_DIR) && ansible-builder build \
			--tag $(EE_FULL_NAME):$(EE_TAG) \
			--extra-build-cli-args="$(ANSIBLE_BUILDER_EXTRA_BUILD_CLI_ARGS)" \
			--verbosity $(ANSIBLE_BUILDER_VERBOSITY)
	@echo "Execution environment built: $(EE_FULL_NAME):$(EE_TAG)"
	@GIT_TAG=$${GIT_TAG:-latest}
	@echo -n "Tagging: $(EE_FULL_NAME):$(EE_TAG) as $(EE_FULL_NAME):$${GIT_TAG} ..."
	@podman \
		$(PODMAN_PARAMS) \
		tag \
			$(PODMAN_TAG_PARAMS) \
			$(EE_FULL_NAME):$(EE_TAG) \
			$(EE_FULL_NAME):$${GIT_TAG}
	@echo " done"

# Push execution environment
ee-push: ee-build
	@echo -n "Pushing: $(EE_FULL_NAME):$(EE_TAG) ..."
	@podman \
		$(PODMAN_PARAMS) \
		push \
			$(PODMAN_PUSH_PARAMS) \
			$(EE_FULL_NAME):$(EE_TAG)
	@echo " done"
	@GIT_TAG=$${GIT_TAG:-latest}
	@echo -n "Pushing: $(EE_FULL_NAME):$${GIT_TAG} ..."
	@podman \
		$(PODMAN_PARAMS) \
		push \
			$(PODMAN_PUSH_PARAMS) \
			$(EE_FULL_NAME):$${GIT_TAG}
	@echo " done"

# Clean execution environment build artifacts
ee-clean:
	@echo "Cleaning execution environment build artifacts"
	@rm -rf $(EE_DIR)/build/
	@echo "Build artifacts cleaned"

# Show execution environment info
ee-info:
	@echo "Execution Environment Information:"
	@echo "  EE Directory: $(EE_DIR)"
	@echo "  EE Name: $(EE_NAME)"
	@echo "  EE Tag: $(EE_TAG)"
	@echo "  Full Image: $(EE_FULL_NAME):$(EE_TAG)"
	@echo "  Git Commit Hash: $(GIT_COMMIT_HASH)"
	@echo "  Git Tag (if any): $(GIT_TAG)"
	@echo "  EE uses hash as tag: $(EE_TAG)"


# Run playbook using ansible-navigator with your EE
ee-navigator-run:
	@echo "Running playbook $(EE_NAV_PLAYBOOK) using ansible-navigator with your EE ($(EE_NAME))"
	ansible-navigator run \
		--execution-environment-image $(EE_FULL_NAME):$(EE_TAG) \
		--mode $(EE_NAV_MODE) \
		--pull-policy $(EE_NAV_PULL_POLICY) \
		$(EE_NAV_PLAYBOOK) \
		$(EE_NAV_EXTRA_VARS)

# Interactive ansible-navigator
ansible-nav-interactive:
	ansible-navigator \
		--execution-environment-image $(EE_FULL_NAME):$(EE_TAG) \
		--mode interactive

